# Exercise 5
## Structs, unions and bitfields

Reading: Chapter 5 of *Head First C*, Chapter 5 of *Think OS*, and
[this paper about generating random floating-point
values](http://allendowney.com/research/rand/downey07randfloat.pdf)


1) In this directory, read over `rand.c` and `test1.c`, then
compile and run `test1.c`.  It should generate 10000 random numbers
between 0 and 1.

* Yup!

2) If you pipe the output from `test1.c` into `check_uniform.py`, it should
plot the CDF of the values generated by `test1.c`.  If the values
are uniformly distributed from 0 to 1, the result should be a straight
line.

* The line is straight.

3) Repeat this test with `test2.c` to confirm that the values generated
by `my_random_float` have the right distribution.

* Line is also straight.

4) Read through `time_rand.c`, then compile and run it.  Which
random number generator is the fastest?

* `random_float` is fastest at 890ms, followed by `my_random_float` at 1043ms and `my_random_float2` at 2221ms.

5) Fill in the body of `my_random_double` to generate random doubles,
rather than floats.  Test it to see if it
returns numbers uniformly distributed from 0 to 1.

* It does. I changed all the ints to longs and copied `my_random_float2` wholesale with wikipedia pages of IEEE single- and double- precision floats open. Changing 8 to 11, 23 to 52 (and incrementing all their sums with other numbers accordingly) as well as adjusting the bias upward accordingly (126 -> 1022 to accomodate the 128->1024 change) seems to have done the trick.

6) Modify `time_rand.c` to compare `my_random_double` and
`random_double`.  Which is faster?

* `random_double` is more than twice as fast, at 1200ms instead of 3000+ ms.

7) Check in your modified version of `rand.c` and `time_rand.c`.


## Object-oriented C

1) In this directory you should find

*  find_track.c: A solution from `ex02.5`.

*  find_track_oo.c: An outline of an object-oriented solution, which you will fill in.

Compile and run `find_track.c`, just to make sure it still works.

2) Compile and run `find_track_oo.c`.  It should compile and run, but
not find any tracks.

3) Fill in the bodies of the empty functions and get `find_track_oo.c` working.

4) Check `find_track_oo.c` in to the repo.